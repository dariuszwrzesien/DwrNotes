async_await

W poprzednim artykule z cyklu podstaw języka JavaScript pokazałem jak zastosowanie obietnic pozytywnie wpłyneło na pracę z kodem asynchronicznym i pozbycie się piekła wywołań zwrotnych (callback hell). Okazuje się jednak że istnienje możliwość zapisu kodu asynchronicznego w taki sposób że czyta się go tak jakby był synchroniczny.

Załóżmy że chcemy napisać program, który połączy się z zewnętrznym API w celu pobrania nazyw miasta i na jej podstawie z innego zewnętrznego API pobierze dane pogodowe.

W uproszczeniu, kod taki realizować będzie następujące operacje.

const city = asyncGetCity();
const weather = asyncGetWeather(city);
console.log(weather.temp);

Jednakże, ponieważ pracujemy z kodem asynchronicznym to w takim przypadku użyjemy obietnic, aby uzyskac następujący rezultat:


return asyncGetCity()
    .then(function(city) {
        return asyncGetWeather(city);
    })
    .then(function(weather) {
        console.log(weather.temp);
    })


Mamy tutaj do czynienia z typowym asynchronicznym łańcuchem zależności. Potrzebujemy posiadać nazwę miasta aby na jego podstawie pobrać infornache pogodowe.
Użycie obietnic w porówaniu z pierwszym zapisem niesie za sobą jednak pewne ograniczenia. Jeśli chcielimyśmy wypisać w konsoli oprócz temperatury również nazwę miasta, musielibyśmy zapisywac ją w dodatkowej zmiennej.


let City; //podkreslic
return asyncGetCity()
    .then(function(city) {
        City = city; //podkreslic
        return asyncGetWeather(city);
    })
    .then(function(weather) {
        console.log(City);
        console.log(weather.temp);
    })

Generatory

Jedną z możliwości poprawy zapisu jest użycie generatorów wprowadzonych do języka JavaScript od wersji ES6. W skrócie, generator to specjalny rodzaj funkcji (oznaczamy go za pomoca * za słowem kluczowym function), której przebieg może być zatrzymywany i wznawiany z zachowaniem konteksu (variable bindings). Wywołanie generatora nie wykonuje od razu poleceń w nich zawartych, zwraca natomiast obiekt iteratora. Następnie za pomocą metody next() wykonywany jest kod wewnątrz funkcji.

Najprostrza implementacja generatora mogłaby wyglądać następująco:

function *foo(x) {
    yield x + 1;

    let y = yield 'Hello'; 

    return x + y;
}

var gen = foo(5);
console.log(gen.next()); // { value: 6, done: false }
console.log(gen.next()); // { value: 'Hello', done: false }
console.log(gen.next(8)); // { value: 13, done: true }

Przebieg powyżsego kodu jest następujący.
1. Podczas var gen = foo(5) zwracany jest obiekt iteratora.
2. Pierwsze wywołanie metody next() na obiekcie iteratora powoduje przypisanie wartości 5 do zmiennej x, zatrzymaniu wykonywania funkcji na słowie kluczowym yield oraz zwrócenie wartości {value: 6, done: false}.
3. Drugie wywołanie metody next() powoduje zatrzymanie wykonywania kodu na drugim słowie kluczowym yield i zwrócenie komunikatu 'Hello' w postaci {value: "Hello", done: false}.
4. Kolejne wykonanie metody next() tym razem z przekazaną wartością 8 przypisuje przekazaną wartość w miejscu zatrzymania funkcji czyli let y = yield oraz zwraca wynik z obliczeń x + y (czyli 5 + 8) oraz informację o zakończeniu działania iteratora done: true {value: 13, done: true}.


Niechciałbym jednak skupiać się w tym miejscu na szczegółowym opisie możliwości generatorów. W konteksice opisywanych async/await chciałbym pokazać zastosowanie generatorów w pracy z kodem asynchronicznym.



















https://jlongster.com/A-Study-on-Solving-Callbacks-with-JavaScript-Generators

https://davidwalsh.name/async-generators


https://medium.freecodecamp.org/javascript-from-callbacks-to-async-await-1cc090ddad99
https://www.toptal.com/javascript/asynchronous-javascript-async-await-tutorial
https://tutorialzine.com/2017/07/javascript-async-await-explained

dobry opis
https://javascript.info/async-await







jak wykonać  w jednym asyn function dwa strzały jednoczesnie (opisać i zrobić screeny z consoli)


async fybctuib run() {

const w = fetch()
const e = fetch()


await
await

}

