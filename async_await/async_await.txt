async_await

W poprzednim artykule z cyklu podstaw języka JavaScript pokazałem jak zastosowanie obietnic pozytywnie wpłyneło na pracę z kodem asynchronicznym i pozbycie się piekła wywołań zwrotnych (callback hell). Okazuje się jednak że istnienje możliwość zapisu kodu asynchronicznego w sposób bardziej czytelny.

Załóżmy że chcemy napisać program, który połączy się z zewnętrznym API w celu pobrania nazyw miasta i na jej podstawie z innego zewnętrznego API wczyta dane pogodowe.

W uproszczeniu, kod taki realizować będzie następujące operacje.

const cityAPI = 'https://api?q=randomCity';
const weatherAPI = 'https://api?q=weather&cityName=';

const city = fetch(cityAPI);
const weather = fetch(weatherAPI+city.name);
console.log(weather.temp);

Jednakże, ponieważ pracujemy z kodem asynchronicznym to w takim przypadku użyjemy obietnic i uzyskamy następujący zapis:

const cityAPI = 'https://www.mocky.io/v2/5a945fa435000074009b0e78';
const weatherAPI = 'http://www.mocky.io/v2/5a947dfa35000072009b0eb9';

function asyncGetCity() {
    return fetch(cityAPI).then(response => response.json());
}

function asyncGetWeather(city) {
    return fetch(weatherAPI).then(response => response.json());
}

return asyncGetCity()
    .then(function(city) {
        return asyncGetWeather(city.name);
    })
    .then(function(weather) {
        console.log(weather.temp);
    })


Mamy tutaj do czynienia z typowym asynchronicznym łańcuchem zależności. Potrzebujemy posiadać nazwę miasta aby na jego podstawie pobrać informacje pogodowe.

Jak widać użycie obietnic w porównaniu z pierwszym zapisem niesie ze sobą pewną nadmiarowość ale także i ograniczenia. Jeśli chcielimyśmy wypisać w konsoli oprócz temperatury również nazwę miasta, musielibyśmy zapisać ją w dodatkowej zmiennej.

let City; //podkreslic
return asyncGetCity()
    .then(function(city) {
        City = city; //podkreslic
        return asyncGetWeather(city);
    })
    .then(function(weather) {
        console.log(City);
        console.log(weather.temp);
    })

Czy nie było by idealnie, gdybyśmy mieli możliwość zapisu kodu asychronicznego w taki sposób aby był on tak czytelny jak kod synchroniczny ?

Generatory

Jedną z możliwości poprawy zapisu jest użycie generatorów wprowadzonych do języka JavaScript od wersji ES6. W skrócie, generator to specjalny rodzaj funkcji (oznaczamy go za pomoca * za słowem kluczowym function), której przebieg może być zatrzymywany i wznawiany z zachowaniem konteksu (variable bindings). Wywołanie generatora nie wykonuje od razu poleceń w nich zawartych, zwraca natomiast obiekt iteratora. Następnie za pomocą metody next() wykonywany jest kod wewnątrz funkcji.

Zobaczmy na przykładzie w jaki sposób działa generator w JavaScript.

function *foo(x) {
    yield x + 1;

    let y = yield 'Hello'; 

    return x + y;
}

var gen = foo(5);
console.log(gen.next()); // { value: 6, done: false }
console.log(gen.next()); // { value: 'Hello', done: false }
console.log(gen.next(8)); // { value: 13, done: true }

https://jsfiddle.net/hu6f72Le/

Przebieg powyższego skryptu jest następujący.
1. Podczas przypisania funkcji do zmiennej var gen = foo(5) zwracany jest obiekt iteratora.
2. Pierwsze wywołanie metody next() na obiekcie iteratora powoduje przypisanie wartości 5 do zmiennej x, zatrzymaniu wykonywania funkcji na słowie kluczowym yield oraz zwróceniu wartości {value: 6, done: false}.
3. Drugie wywołanie metody next() powoduje zatrzymanie wykonywania kodu na drugim słowie kluczowym yield i zwrócenie komunikatu 'Hello' w postaci {value: "Hello", done: false}.
4. Kolejne wykonanie metody next() tym razem z przekazaną wartością 8 przypisuje przekazaną wartość w miejscu zatrzymania funkcji czyli let y = yield 'Hello' (let y = 8) oraz zwraca wynik z obliczeń x + y ( 5 + 8) oraz informację o zakończeniu działania iteratora done: true {value: 13, done: true}.


Niechciałbym jednak skupiać się w tym miejscu na szczegółowym opisie możliwości generatorów, a bardziej na ich połączeniu z obietnicami i zastosowaniu w pracy z kodem asynchronicznym. 
Tak więc powracając do przykładu z początku artykułu użyjmy generatora aby pobrać informacje pogodowe dla danego miasta.























https://jlongster.com/A-Study-on-Solving-Callbacks-with-JavaScript-Generators

https://davidwalsh.name/async-generators


https://medium.freecodecamp.org/javascript-from-callbacks-to-async-await-1cc090ddad99
https://www.toptal.com/javascript/asynchronous-javascript-async-await-tutorial
https://tutorialzine.com/2017/07/javascript-async-await-explained

dobry opis
https://javascript.info/async-await







jak wykonać  w jednym asyn function dwa strzały jednoczesnie (opisać i zrobić screeny z consoli)


async fybctuib run() {

const w = fetch()
const e = fetch()


await
await

}

