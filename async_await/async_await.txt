async_await

W poprzednim artykule z cyklu podstaw języka JavaScript pokazałem jak zastosowanie obietnic pozytywnie wpłyneło na pracę z kodem asynchronicznym i pozbycie się piekła wywołań zwrotnych (callback hell). Okazuje się jednak że istnienje możliwość zapisu kodu asynchronicznego w sposób bardziej czytelny.

Załóżmy że chcemy napisać program, który połączy się z zewnętrznym API w celu pobrania nazyw miasta i na jej podstawie z innego zewnętrznego API wczyta dane pogodowe.

W uproszczeniu, kod taki realizować będzie następujące operacje.

const cityAPI = 'https://api?q=randomCity';
const weatherAPI = 'https://api?q=weather&cityName=';

const city = fetch(cityAPI);
const weather = fetch(weatherAPI+city.name);
console.log(weather.temp + weather.unit);

Jednakże, ponieważ pracujemy z kodem asynchronicznym to w takim przypadku użyjemy obietnic i uzyskamy następujący zapis:

const cityAPI = 'https://www.mocky.io/v2/5a945fa435000074009b0e78';
const weatherAPI = 'https://www.mocky.io/v2/5a947dfa35000072009b0eb9?city=';

function asyncGetCity() {
    return fetch(cityAPI).then(response => response.json());
}

function asyncGetWeather(city) {
    return fetch(weatherAPI+city).then(response => response.json());
}

return asyncGetCity()
    .then(function(city) {
        return asyncGetWeather(city.name);
    })
    .then(function(weather) {
        console.log(weather.temp + weather.unit);
    })

https://jsfiddle.net/f80ny7ke/

Mamy tutaj do czynienia z typowym asynchronicznym łańcuchem zależności. Potrzebujemy posiadać nazwę miasta aby na jego podstawie pobrać informacje pogodowe.

Jak widać użycie obietnic w porównaniu z pierwszym zapisem niesie ze sobą pewną nadmiarowość ale także i ograniczenia. Jeśli chcielimyśmy wypisać w ostatnim wywołaniu oprócz temperatury również nazwę miasta, musielibyśmy zapisać ją w dodatkowej zmiennej.

let cityName;
return asyncGetCity()
    .then(function(city) {
        cityName = city.name;
        return asyncGetWeather(cityName);
    })
    .then(function(weather) {
        console.log(cityName)
        console.log(weather.temp + weather.unit);
    })

https://jsfiddle.net/f80ny7ke/1/

Czy nie było by idealnie, gdybyśmy mieli możliwość zapisu kodu asychronicznego w taki sposób aby był on tak czytelny jak kod synchroniczny ?

Generatory

Jedną z możliwości poprawy czytelności jest zapis z użyciem generatorów, wprowadzonych do języka JavaScript od wersji ES6. W skrócie, generator to specjalny rodzaj funkcji (oznaczamy go za pomoca * za słowem kluczowym function), której przebieg może być zatrzymywany i wznawiany z zachowaniem konteksu (variable bindings). Wywołanie generatora nie wykonuje od razu poleceń w nich zawartych, zwraca natomiast obiekt iteratora. Następnie za pomocą metody next() wykonywany jest kod wewnątrz funkcji.

Zobaczmy na przykładzie w jaki sposób działa generator w JavaScript.

function *foo(x) {
    yield x + 1;

    let y = yield 'Hello'; 

    return x + y;
}

var gen = foo(5);
console.log(gen.next()); //{ value: 6, done: false }
console.log(gen.next()); //{ value: 'Hello', done: false }
console.log(gen.next(8)); //{ value: 13, done: true }

https://jsfiddle.net/hu6f72Le/

Przebieg powyższego skryptu jest następujący.
1. Podczas przypisania funkcji do zmiennej var gen = foo(5) zwracany jest obiekt iteratora.
2. Pierwsze wywołanie metody next() na obiekcie iteratora powoduje przypisanie wartości 5 do zmiennej x, zatrzymaniu wykonywania funkcji na słowie kluczowym yield oraz zwróceniu wartości {value: 6, done: false}.
3. Drugie wywołanie metody next() powoduje zatrzymanie wykonywania kodu na drugim słowie kluczowym yield i zwrócenie komunikatu 'Hello' w postaci {value: "Hello", done: false}.
4. Kolejne wykonanie metody next(), tym razem z przekazaną wartością 8, przypisuje przekazaną wartość w miejscu zatrzymania funkcji, czyli let y = yield 'Hello' (let y = 8), zwraca wynik z obliczeń return x + y (5 + 8) oraz informację o zakończeniu działania iteratora done: true. W konsoli ukazuje się nam wpis: {value: 13, done: true}.

Niechciałbym jednak skupiać się w tym miejscu na szczegółowym opisie możliwości generatorów, a bardziej na ich połączeniu z obietnicami i zastosowaniu w pracy z kodem asynchronicznym. 
Tak więc, powracając do przykładu z początku artykułu użyjmy generatora aby pobrać informacje pogodowe dla danego miasta.

const cityAPI = 'https://www.mocky.io/v2/5a945fa435000074009b0e78';
const weatherAPI = 'https://www.mocky.io/v2/5a947dfa35000072009b0eb9?city=';

function *app(){
    const city = yield fetch(cityAPI).then(r => r.json());
    const weather = yield fetch(weatherAPI+city).then(r => r.json());
    console.log(city.name);
    console.log(weather.temp + weather.unit);
}

const generator = app();
start(generator);


function start(generator) {
   remind();
   function remind(wait){
       const next = generator.next(wait);
       const promise = next.value;

       if (next.done) {
          return;
       }

       promise.then(result => remind(result))
   }
}

https://jsfiddle.net/soompm9r/


Funkcja *app() pokazuje siłę generatorów w pracy z kodem asynchronicznym. Porównując kod zawarty w tej funkcji z kodem synchronicznym z początku artykułu zauważysz że jest on niemal identyczny. To wielka zaleta stosowania generatorów w połączeniu z obietnicami,

Jęśli chodzi o metodę start() na tę chwilę nie zaprzątajmy sobie nią głowy. Jest ona szczegółem implementacyjnym do którego wrócimy w dalszej części.

Async/await

Po tym obszernym wstępie przejdzmy wkońcu do omówienia async/await. Z wiedzą jaką posiadamy na temat generatorów będzie to niezwykle proste.


Pokazać zamiane * na async i yeield na await oraz wyrzucic metodę start.


Wyrzucamy metąde start() ponieważ jej zadanie przejeła implementacja async/await w silniku JavaScript. ??



Obsługa błędów (try catch) - ale to już chyba w async await











https://jlongster.com/A-Study-on-Solving-Callbacks-with-JavaScript-Generators

https://davidwalsh.name/async-generators


https://medium.freecodecamp.org/javascript-from-callbacks-to-async-await-1cc090ddad99
https://www.toptal.com/javascript/asynchronous-javascript-async-await-tutorial
https://tutorialzine.com/2017/07/javascript-async-await-explained

dobry opis
https://javascript.info/async-await







jak wykonać  w jednym asyn function dwa strzały jednoczesnie (opisać i zrobić screeny z consoli)


async fybctuib run() {

const w = fetch()
const e = fetch()


await
await

}

