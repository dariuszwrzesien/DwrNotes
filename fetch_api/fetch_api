Fetch API jest interfejsem pozwalającym na asynchroniczne pobieranie zasobów. Dotychczas aby pobrać zasób z serwera korzystało się z obiektu XMLHttpRequest (XHR). Fetch API powstało aby uprościć sposób komunikacji z serwerem, korzysta także z obietnic (link do obietnic) co bardziej odpowiada dzisiejszym standardom programowania i zapobiega wielokrotnym wywołaniom zwrotnym.

Zobaczmy jak wyglądała komunikacja z serwerem zanim powstało Fetch API.

Większość przeglądarek w tamtych czasach wykorzystywała obiekt XMLHttpRequest w celu pobierania zasobów z serwera. Większość to niestety nie znaczy wszystkie. Microsoft w przeglądarce Internet Explorer zaimplementował ten standard jako ActiveXObject co spowodowało że jeśli chcieliśmy aby nasz program działał zarówno na IE jak też na Safari czy pod Netscape należało wspierać oba te rozwiązania.

var request;
if (window.XMLHttpRequest) { // Mozilla, Safari, ...
  request = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    request = new ActiveXObject('Msxml2.XMLHTTP');
  } 
  catch (e) {
    try {
      request = new ActiveXObject('Microsoft.XMLHTTP');
    } 
    catch (e) {}
  }
}


Mając utworzony obiekt request mogliśmy następnie wysłać żądanie do serwera.

request.open('GET', 'https://jsonplaceholder.typicode.com/posts/1', true);
request.send();
// state changes
request.onreadystatechange = function() {
	if(request.readyState === 4) { // done
		if(request.status === 200) { // complete	
			console.log(request.responseText)
		}
	}
};

https://jsfiddle.net/gz5exu5x/

W powyższym przykładzie posłużyliśmy się EventHandlerem o nazwie onreadystatechange, który wywoływany jest za każdym razem gdy zmieni się stan readyState. XMLHttpRequest.readyState może odpowiedzieć jednym z pięciu stanów od 0 do 4. Dzięki temu mogliśmy sprawdzić na jakim etapie jest przetwarzanie naszego żądania. Status oznaczony cyfrą 4 (Done) informował że żądanie zostało zakończone i można było przejść do zbadania jakim statusem http odpowiedział serwer. W powyższym przykładzie sprawdzamy czy żądanie zakończyło się statusem 200 (OK) i jeśli tak to przystępujemy do wypisania otrzymanych danych na konsoli.

Ponieważ korzystanie z tak niskopoziomowego API nie należało do najwygodniejszych, powstało wiele bibliotek opakowujących XHR. Do najpopularniejszych należały rozwiązania a biblioteki Jquery:
jQuery.ajax(), jQuery.get(), jQuery.post(). 

$.ajax('https://jsonplaceholder.typicode.com/posts/1', {
  success: (data) => {
  	console.log(JSON.stringify(data));
  },
});

https://jsfiddle.net/3g4ww3t2/

Aby polecenie ajax() zadziałało w ten sam sposób, co porzednio zaprezentowane, wystarczyło wywołać metodę ajax() z odpowiednim parametrem i odpowiednio obsłużyć dane, które otrzymaliśmy.

FETCH API

Przez ponad dekadę użycie obiektu XMLHttpRequest było jedynym sposobem na stworzenie asynchronicznego żądania w JavaScript. Pomimo ogromnej użyteczności, używanie XHR nie należało do najprzyjemniejszych. Podstawowe wady tego rozwiązania to:
 - brak separacji zagadnień (Separation of Concern),
 - stan żądania oraz jego input i output były zarządzane poprzez interakcje z jednym obiektem,
 - użycie Eventów do śledzenia stanu obiektu odstaje od obecnych standardów skupionych wokół Promisów (obietnic link).

Fetch API rozwiązuje większość problemów związanych z użyciem XHR, a ponieważ korzysta z obietnic, tym samym zapobiega wielokrotnym wywołaniom zwrotnym zwanym "callback hell". Fetch API wprowadza do języka JavaScript obiekty Headers, Request, Response i Body, których nazwy dobrze znamy z protokołu HTTP.

Podstawą pracy z FetchAPI jest użycie metody fetch() do asynchronicznego pobrania danych z serwera.
Zobaczmy jak to działa na najprostrzym przykładzie.

fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => response.json())
  .then(json => console.log(json));

W przykładzie powyżej metoda fetch() jako parametr przyjmuje adres URL do zdalnego zasobu. Następnie po wykonaniu żądania, odpowiedź zamienia na obiekt za pomocą metody json() (https://developer.mozilla.org/en-US/docs/Web/API/Body/json), otrzymany obiekt wypisujemy na konsolę.

https://jsfiddle.net/j1vs64vx/

Oczywiście oprócz pobierania danych za pomocą metody HTTP GET, możemy także komunikować się za pomocą różnych innych metod HTTP (POST, PUT, DELETE czy też OPTIONS). Przykład poniżej pokazuje jak wysłać dane za pomoca metody POST.

const data = {
    title: 'Test title',
    body: 'Test body',
    userId: 42
}

const options = {
   method: 'POST',
   body: JSON.stringify(data),
   headers: {
       'Content-Type': 'application/json'
   }
};

fetch('https://jsonplaceholder.typicode.com/posts', options)
  .then(response => response.json())
  .then(json => console.log(json));

https://jsfiddle.net/6dhqcjop/

Na początku tworzymy obiekt data z danymi które chcemy wysłać, następnie w obiekcie option definujemy rodzaj metody HTTP, w naszym przypadku POST, a do zmiennej body przypisujemy wcześniej utworzony obkiekt data. Podobnie jak w poprzenim przykładzie też jako pierwszy parametr ustawiamy adres URL pod który będziemy wysyłac dane, drugim parametrem będzie nasz obiekt option na podstawie którego metoda fetch określi jaką metode http ma użyć do wysłania danych, z jakimi danymi i jakimi nagłówkami.

W odpowiedzi serwis  jsonplaceholder zwróci nam następujący obiekt który wypiszemy na konsoli.

{
  "title": "Test title",
  "body": "Test body",
  "userId": 42,
  "id": 101
}

Fetch + async/await

Ponieważ metoda fetch() zawsze zwróci nam obietnicę, świetnie sie nam to wpisuje w konwencję async/await. (Jeśli temat async/await nie jest Ci dobrze znany zachęcam do zapoznania się z artykułem na ten temat - link !!!)

Dzięki czemu możemy sprawić że nasz kod będzie bardziej czytelny i łatwiejszy do zrozumienia.

Poniżej przykład zastosowania async/await do pobrania listy imion użytkowników z serwisu jsonplaceholder.

async function fetchUsers(url) {
  const response = await fetch(url);
  const json = await response.json();

  const listOfusernames = json.map(user => user.username);

  console.log(listOfusernames);
}

fetchUsers('https://jsonplaceholder.typicode.com/users');

W odpowiedzi na konsoli powinniśmy zobaczyć tablicę z imionami użytkowników

[
  "Bret",
  "Antonette",
  "Samantha",
  "Karianne",
  "Kamren",
  "Leopoldo_Corkery",
  "Elwyn.Skiles",
  "Maxime_Nienow",
  "Delphine",
  "Moriah.Stanton"
]


Wspomniałem wcześniej że Fetch API oprócz metody fetch() wprowadziło do języka JavasScript obiekty Response, Request i Body. Obiekty te wykorzystywane są głównie podczas pracy z Service Workerami (więcej na temat Service Workerów możesz przeczytać w artykule o Progressive Web Apps http://devenv.pl/progressive-web-apps/).
Przyjrzyjmy się każdemu z nich z osobna.

Response

Jak możemy zauważyć w przykładzie poniżej, rezultatem jaki zwróci nam metoda fetch() nie są tylko dane wystawione przez serwer ale cały obiekt Response, w którym znajdziemy informację na temat żądania i odpowiedzi.

async function fetchUsers(url) {
  const response = await fetch(url);
  console.log(response);
}

fetchUsers('https://jsonplaceholder.typicode.com/users');

https://jsfiddle.net/nfmoLn8a/

Na konsoli zostanie wypisany następujący obiekt:

Response {
type: "cors", 
url: "https://jsonplaceholder.typicode.com/users", 
redirected: false, 
status: 200, 
ok: true, 
body: ReadableStream, 
bodyUsed: false, 
headers: Headers
}


headers

Właściwość headers w obiekcie Response jest obiektem Headers który udostępnia nam między innymi metody has() oraz get() za pomocą których możemy sprawdzić nagłówki otrzymanej odpowiedzi z serwera. 

async function fetchUsers(url) {
  const response = await fetch(url);
  console.log(response.headers.has('Content-Type')); //true
  console.log(response.headers.get('Content-Type')); //application/json; charset=utf-8
}

fetchUsers('https://jsonplaceholder.typicode.com/users');

https://jsfiddle.net/13oyd340/

status / statusText

Status zwraca nam odpowiedni kod odpowiedzi HTTP a statusText jego reprezentację tekstową. Więcej informacji na ten temat możesz znaleźć w wikipedii https://pl.wikipedia.org/wiki/Kod_odpowiedzi_HTTP












Wady






3. Handling errors with Fetch
https://medium.com/@shahata/why-i-wont-be-using-fetch-api-in-my-apps-6900e6c6fe78
What is a big deal, and what I’m sure many readers missed in the above example (as did I, when I first used fetch), is that actually the two code snippets above do not do the same thing. All of the http toolkits I mentioned above (seriously, each and every one of them) treat a response with error status from the server (i.e. status 404, 500, etc.) as an error. However, fetch (similarly to XMLHttpRequest) rejects the promise only in case of network error (i.e. address could not be resolved, server is unreachable or CORS not permitted).
This means that when server returns 404, we will print ‘success’ to the console. If we want to do the more intuitive thing for an application developer and return a promise rejection in case server responded with an error, we’ll need to do something like this:
fetch(url)
  .then(response => {
    return response.json().then(data => {
      if (response.ok) {
        return data;
      } else {
        return Promise.reject({status: response.status, data});
      }
    });
  })
  .then(result => console.log('success:', result))
  .catch(error => console.log('error:', error));


Podsumowanie.
Fetch API jest wspierane we wszystkich nowoczesnych przegladarkach
fetch_api_support.png,
jeśli jednak istnieje konieczność użycia na niewspieranej platformie - można użyć polify: https://github.com/github/fetch

If you need to use Fetch in Node.js, two of the most popular options are isomorphic-fetch and node-fetch.


Wady. !!!!!1
https://medium.com/@shahata/why-i-wont-be-using-fetch-api-in-my-apps-6900e6c6fe78
Jak poradzić sobie z wyżej opisaną wadą: https://css-tricks.com/using-fetch/
Obsługa błędów - porównanie z axios

Abort Signal
https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal

Linki:
https://flaviocopes.com/fetch-api/
https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/
https://developers.google.com/web/updates/2015/03/introduction-to-fetch
https://medium.com/@shahata/why-i-wont-be-using-fetch-api-in-my-apps-6900e6c6fe78
https://scotch.io/tutorials/how-to-use-the-javascript-fetch-api-to-get-data
https://css-tricks.com/using-fetch/
https://www.sitepoint.com/introduction-to-the-fetch-api/


https://jakearchibald.com/2015/thats-so-fetch/


https://medium.com/beginners-guide-to-mobile-web-development/the-fetch-api-2c962591f5c








https://alligator.io/js/fetch-api/
