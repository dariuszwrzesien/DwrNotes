Fetch API jest interfejsem pozwalającym na asynchroniczne pobieranie zasobów. Dotychczas aby pobrać zasób z serwera korzystało się z obiektu XMLHttpRequest (XHR). Fetch API powstało aby upraścić sposób komunikacji z serwerem, korzysta także z obietnic (link do obietnic) co bardziej odpowiada dzisiejszym standardom programowania i zapobiega wielokrotnym wywołaniom zwrotnym.

Zobaczmy jak wyglądała komunikacja z serwerem zanim powstało Fetch API.

Większość przeglądarek w tamtych czasach wykorzystywała implementację obiektu XMLHttpRequest w celu pobierania zasobów z serwera. Większość to niestety nie znaczy wszystkie. Microsoft w przeglądarce Internet Explorer zaimplementował ten standard jako ActiveXObject co spowodowało że jeśli chcieliśmy aby nasz program działał zarówno na IE jak też na Safari czy pod Netscape należało wspierać oba te rozwiązania.

var request;
if (window.XMLHttpRequest) { // Mozilla, Safari, ...
  request = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    request = new ActiveXObject('Msxml2.XMLHTTP');
  } 
  catch (e) {
    try {
      request = new ActiveXObject('Microsoft.XMLHTTP');
    } 
    catch (e) {}
  }
}


Mając utworzony obiekt request mogliśmy następnie wysłać żądanie do serwera.

request.open('GET', 'https://jsonplaceholder.typicode.com/posts/1', true);
request.send();
// state changes
request.onreadystatechange = function() {
	if(request.readyState === 4) { // done
		if(request.status === 200) { // complete	
			console.log(request.responseText)
		}
	}
};

https://jsfiddle.net/gz5exu5x/

W powyższym przykładzie posłużyliśmy się EventHandlerem o nazwie onreadystatechange, który wywoływany jest za każdym razem gdy zmieni się stan readyState. XMLHttpRequest.readyState może odpowiedzieć jednym z pięciu stanów od 0 do 4. Dzięki temu mogliśmy sprawdzić na jakim etapie jest przetwarzanie naszego żądania. Status oznaczony cyfrą 4 (Done) informował że żądanie zostało zakończone i można było przejść do zbadania jakim statusem http odpowiedział serwer. W powyższym przykładzie sprawdzamy czy żądanie zakończyło się statusem 200 (OK) i jeśli tak to przystępujemy do wypisania otrzymanych danych na konsoli.

Ponieważ korzystanie z tak niskopoziomowego API nie należało do najwygodniejszych, powstało wiele bibliotek opakowujących XHR. Do najpopularniejszych należały rozwiązania a biblioteki Jquery:
jQuery.ajax(), jQuery.get(), jQuery.post(). 

$.ajax('https://jsonplaceholder.typicode.com/posts/1', {
  success: (data) => {
  	console.log(JSON.stringify(data));
  },
});

https://jsfiddle.net/3g4ww3t2/

Aby polecenie ajax() zadziałało w ten sam sposób co porzednio zaprezentowane wystarczyło wywołać metodę ajax() z odpowiednim parametrem i odpowiednio obsłużyć dane, które otrzymaliśmy.

FETCH API

Przez ponad dekadę użycie obiektu XMLHttpRequest było jedynym sposobem na stworzenie asynchronicznego żądania w JavaScript. Pomimo ogromnej użyteczności, używanie XHR nie należało do najprzyjemniejszych. Podstawowe wady tego rozwiązania to:
 - brak separacji zagadnień (Separation of Concern),
 - stan żądania oraz jego input i output były zarządzane poprzez interakcje z jednym obiektem,
 - użycie Eventów do śledzenia stanu obiektu odstaje od obecnych standardów skupionych wokół Promisów (obietnic link).

Fetch API rozwiązuje większość problemów związanych z użyciem XHR, a ponieważ korzysta z obietnic, tym samym zapobiega wielokrotnym wywołaniom zwrotnym zwanym "callback hell". Fetch API wprowadza do języka JavaScript obiekty Headers, Request, Response i Body, których nazwy dobrze znamy z protokołu HTTP.

Podstawą pracy z FetchAPI jest użycie metody fetch() do asynchronicznego pobrania danych z serwera.
Zobaczmy jak to działa na najprstrzym przykładzie.

fetch('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => response.json())
  .then(json => console.log(json));

W wyżej pokazanym przykładzie metoda fetch jako parametr przyjmuje adres URL do zdalnego zasobu. Następnie po wykonaniu żądania, odpowiedź zamienia na obiekt za pomocą metody json() (https://developer.mozilla.org/en-US/docs/Web/API/Body/json), otrzymany obiekt wypisujemy na konsolę.

https://jsfiddle.net/j1vs64vx/




2. POST, put, delete 
https://alligator.io/js/fetch-api/

Fetch async/await https://alligator.io/js/fetch-api/#fetch--asyncawait -> Calling json() returns a promise so in the above example, when we return data in the async function, we're returning a promise.

3. Handling errors with Fetch
https://medium.com/@shahata/why-i-wont-be-using-fetch-api-in-my-apps-6900e6c6fe78
What is a big deal, and what I’m sure many readers missed in the above example (as did I, when I first used fetch), is that actually the two code snippets above do not do the same thing. All of the http toolkits I mentioned above (seriously, each and every one of them) treat a response with error status from the server (i.e. status 404, 500, etc.) as an error. However, fetch (similarly to XMLHttpRequest) rejects the promise only in case of network error (i.e. address could not be resolved, server is unreachable or CORS not permitted).
This means that when server returns 404, we will print ‘success’ to the console. If we want to do the more intuitive thing for an application developer and return a promise rejection in case server responded with an error, we’ll need to do something like this:
fetch(url)
  .then(response => {
    return response.json().then(data => {
      if (response.ok) {
        return data;
      } else {
        return Promise.reject({status: response.status, data});
      }
    });
  })
  .then(result => console.log('success:', result))
  .catch(error => console.log('error:', error));


Podsumowanie.
Fetch API jest wspierane we wszystkich nowoczesnych przegladarkach
fetch_api_support.png,
jeśli jednak istnieje konieczność użycia na niewspieranej platformie - można użyć polify: https://github.com/github/fetch

If you need to use Fetch in Node.js, two of the most popular options are isomorphic-fetch and node-fetch.


Wady. !!!!!1
https://medium.com/@shahata/why-i-wont-be-using-fetch-api-in-my-apps-6900e6c6fe78
Jak poradzić sobie z wyżej opisaną wadą: https://css-tricks.com/using-fetch/
Obsługa błędów - porównanie z axios

Abort Signal
https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal

Linki:
https://flaviocopes.com/fetch-api/
https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/
https://developers.google.com/web/updates/2015/03/introduction-to-fetch
https://medium.com/@shahata/why-i-wont-be-using-fetch-api-in-my-apps-6900e6c6fe78
https://scotch.io/tutorials/how-to-use-the-javascript-fetch-api-to-get-data
https://css-tricks.com/using-fetch/
https://www.sitepoint.com/introduction-to-the-fetch-api/


https://jakearchibald.com/2015/thats-so-fetch/


https://medium.com/beginners-guide-to-mobile-web-development/the-fetch-api-2c962591f5c
