Fetch API jest nowym interfejsem pozwalającym na asynchroniczne pobieranie zasobów. Dotychczas aby pobrać zasób z serwera korzystało się z obiektu XMLHttpRequest (XHR). Fetch API uprastrza sposób komunikacji z serwerem, korzysta także z obietnic (link do obietnic) co bardziej odpowiada dzisiejszym standardom programowania i zapobiega wielokrotnym wywołaniom zwrotnym.

Zobaczmy jak wyglądała komunikacja z serwerem zanim powstało Fetch API.

Większość przeglądarek w tamtych czasach wykorzystywała implementację obiektu XMLHttpRequest w celu pobierania zasobów z serwera. Większość to niestety nie znaczy wszystkie. Microsoft w przeglądarce Internet Explorer zaimplementował ten standard jako ActiveXObject co spowodowało że jeśli chcieliśmy aby nasz program działał zarówno na IE jak też na Safari czy pod Netscape należało wspierać oba te rozwiązania.

var request;
if (window.XMLHttpRequest) { // Mozilla, Safari, ...
  request = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
  try {
    request = new ActiveXObject('Msxml2.XMLHTTP');
  } 
  catch (e) {
    try {
      request = new ActiveXObject('Microsoft.XMLHTTP');
    } 
    catch (e) {}
  }
}


Mając utworzony obiekt request mogliśmy następnie wysłać żądanie do serwera.

request.open('GET', 'https://jsonplaceholder.typicode.com/posts/1', true);
request.send();
// state changes
request.onreadystatechange = function() {
	if(request.readyState === 4) { // done
		if(request.status === 200) { // complete	
			console.log(request.responseText)
		}
	}
};

https://jsfiddle.net/gz5exu5x/

W powyższym przykładzie posłużyliśmy się EventHandlerem o nazwie onreadystatechange, który wywoływany jest za każdym razem gdy zmieni się stan readyState. XMLHttpRequest.readyState może odpowiedzieć jednym z pięciu stanów od 0 do 4. Dzięki temu mogliśmy sprawdzić na jakim etapie jest przetwarzanie naszego żądania. Status 4 (Done) informował że żądanie zostało zakończone i można było przejść do zbadania jakim statusem http odpowiedział serwer. W powyższym przykładzie sprawdzamy czy żądanie zakończyło się statusem 200 (OK) i jeśli tak to przystępujemy do wypisania otrzymanych danych na konsoli.

Ponieważ korzystanie z tak niskopoziomowego API nie należało do najwygodniejszych, powstało wiele bibliotek opakowujących XHR. Do najpopularniejszych należało rozwiązanie zaimplementowane w bibliotece Jquery o nazwie jQuery.ajax()

$.ajax('https://jsonplaceholder.typicode.com/posts/1', {
  success: (data) => {
  	console.log(JSON.stringify(data));
  },
});

https://jsfiddle.net/3g4ww3t2/

Aby polecenie ajax() zadziałało w ten sam sposób co porzednio zaprezentowane wystarczyło wywołać metodę ajax() z odpowiednim parametrem i odpowiednio obsłużyć dane które otrzymaliśmy.

FETCH API
Przez ponad dekade użycie obiektu XMLHttpRequest było jedynym sposobem na stworzenie asynchroonicznego żądania w JavaScript. Pomimo ogromnej użyteczności, używanie XHR nie należało do najprzyjemniejszych. Podstawowe wady tego rozwiązania to:
 - brak separacji zagadnień (Separation of Concern),
 - stan żądania oraz jego input i output były zarządzane poprzez interakcje z jednym obiektem,
 - użycie Eventów do śledzenia stanu obiektu odstaje od obecnych standardów skupionych wokół Promisów (obietnic link).


The Fetch API intends to fix most of these problems. It does this by introducing the same primitives to JS that are used in the HTTP protocol. In addition, it introduces a utility function fetch() that succinctly captures the intention of retrieving a resource from the network.

The Fetch specification, which defines the API, nails down the semantics of a user agent fetching a resource. This, combined with ServiceWorkers, is an attempt to:

Improve the offline experience.
Expose the building blocks of the Web to the platform as part of the extensible web movement.
As of this writing, the Fetch API is available in Firefox 39 (currently Nightly) and Chrome 42 (currently dev). Github has a Fetch polyfill.






Fetch API zbudowane jest na 4 podstawowych koncepcjach:
Request, Response, Headers, Body











1. GET

<Najprostrze użycie fetch>

Fetch returns a Promise link do artykułu o promisach, which is a way to handle asynchronous operations without the need for a callback.


2. POST, put, delete 
https://alligator.io/js/fetch-api/

Fetch async/await https://alligator.io/js/fetch-api/#fetch--asyncawait -> Calling json() returns a promise so in the above example, when we return data in the async function, we're returning a promise.

3. Handling errors with Fetch
https://medium.com/@shahata/why-i-wont-be-using-fetch-api-in-my-apps-6900e6c6fe78
What is a big deal, and what I’m sure many readers missed in the above example (as did I, when I first used fetch), is that actually the two code snippets above do not do the same thing. All of the http toolkits I mentioned above (seriously, each and every one of them) treat a response with error status from the server (i.e. status 404, 500, etc.) as an error. However, fetch (similarly to XMLHttpRequest) rejects the promise only in case of network error (i.e. address could not be resolved, server is unreachable or CORS not permitted).
This means that when server returns 404, we will print ‘success’ to the console. If we want to do the more intuitive thing for an application developer and return a promise rejection in case server responded with an error, we’ll need to do something like this:
fetch(url)
  .then(response => {
    return response.json().then(data => {
      if (response.ok) {
        return data;
      } else {
        return Promise.reject({status: response.status, data});
      }
    });
  })
  .then(result => console.log('success:', result))
  .catch(error => console.log('error:', error));


Podsumowanie.
Fetch API jest wspierane we wszystkich nowoczesnych przegladarkach
fetch_api_support.png,
jeśli jednak istnieje konieczność użycia na niewspieranej platformie - można użyć polify: https://github.com/github/fetch

If you need to use Fetch in Node.js, two of the most popular options are isomorphic-fetch and node-fetch.


Wady. !!!!!1

Obsługa błędów - porównanie z axios

Abort Signal
https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal

Linki:
https://flaviocopes.com/fetch-api/
https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/
https://developers.google.com/web/updates/2015/03/introduction-to-fetch
https://medium.com/@shahata/why-i-wont-be-using-fetch-api-in-my-apps-6900e6c6fe78
https://scotch.io/tutorials/how-to-use-the-javascript-fetch-api-to-get-data
https://css-tricks.com/using-fetch/
https://www.sitepoint.com/introduction-to-the-fetch-api/


https://jakearchibald.com/2015/thats-so-fetch/

