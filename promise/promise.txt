Obietnice. (ang. Promises).


Podstawową informacją od której chciałbym zacząć jest jednowątkowość w JavaScript. Jednowątkowość oznacza że w trakcie działania, program potrafi wykonać tylko jedną czynność na raz według zadanej kolejności. Działa to mniej więcej tak:

fs = require('fs');

console.log(fs.readFileSync('file1.txt', 'utf8'));
console.log(fs.readFileSync('file2.txt', 'utf8'));
console.log(fs.readFileSync('file3.txt', 'utf8'));

W każdym kolejnym kroku, metoda readFileSync() z biblioteki fs odczytuje z dysku plik, przechodząc od pierwszej do ostatniej linii programu, wypisuje do konsoli zawartości kolejno wczytanych plików.

Co jeśli plik jest wyjątkowo duży? Wtedy wczytywanie pliku będzię trwało dłużej, ale dopiero bo wczytaniu całej jego zawartości program przejdzie do kolejnej linii kodu.

Dobrze było by wiec mieć mechanizm pozwalający na wykonanie pewnych zadań w "tle" bez blokowania innych zadań. W tym miejscu z pomocą przychodzi nam asynchroniczność. Jeśli chcemy aby pobranie danych z zewnętrznego API nie blokowało nam działania programu, posłużyć się możemy technologią Ajax, która to asynchronicznie wykona zapytanie do API i zwróci wynik zapytania.

var data = ajax('https://jsonplaceholder.typicode.com/posts/1');
console.log(data);

Jeśli spodziwałeś się że powyższy kod wypisze dane otrzymane z żądania wysłanego przez metodę ajax()* to niestety muszę Cię zmartwić. Zmienna data nie będzie zawierać żadnych danych.
Przebieg programu w wyżej opisanej sytuacji wygląda następująco.

Javasctipt tworzy zmienną data. Następnie uruchamiana jest metoda asynchroniczna ajax() i bez czekania na jej rezultat program stara się wyświetlić zawartość zmiennej data.


---
* metoda ajax() jest metodą poglądową, mającą na celu pokazanie, że zapytanie odbywa się w technologii AJAX.



Zapewnie domyślasz się że w takim razie należy użyć innego podejścia gdy pracujemy z metodami asynchronicznymi. Tak jest! Sposobów na pracę z kodem asynchronicznym jest kilka. Zacznijmy zatem od klasycznego podejścia z użyciem wywołań zwrotnych (ang. callback).



Callback

Potrzebujemy zatem jakiegoś mechanizmu, który pozwoli nam na obsługę tego typu zdarzeń. W przeszłości używaliśmy w tym celu funkcji zwanej "callback". Dla przypomnienia, funkcja "callback" to funkcja przekazana jako parametr innej funkcji. Dzięki takiemu mechanizmowi, możliwe jest wskazanie działania, które ma nastąpić w zależności od wyników działania poprzedniej funkcji. Niestety tego typu podejście ma swoje wady. W wyniku wielokrotnego zagnieżdzania funkcji "callback", powstały w ten sposób kod jest trudny w utrzymaniu i mało czytelny a użycie  Tego typu podejście nazywane jest nazywany mianem callback hell lub piramid of doom,



ilustracja callback hell, piramid of doom




Obietnice powstały z myślą o usprawnieniu pracy z kodem asynchronicznym, ich podstawowymi zaletami są:
lepsza kontrola w zakresie synchronizacji (brak wyścigów), obsługa błędów oraz lepsza czytelność.

Poniżej przykład działania obietnic. (https://jsfiddle.net/9z2frum7/)


function myAsync() {
  const imCool = true;
  return new Promise((resolve, reject) => {
    // w tym miejscu moglibyśmy wstawić 
    // metodę ajaxową za pomocą której 
    // pobieralibyśmy dane z zewnętrzengo API
    if (imCool) {
        resolve('Success!');
    } else {
        reject('Something went wrong')
    }
  });
}

function init() {
  myAsync().then((response) => {
    alert(response);
  })
  .catch((err) => {
    alert(err);
  });
}

init();

Metoda myAsync() tworzy obietnicę że asynchronicznie zrealizuje połączenie i zwróci rezultat.

Obietnica może znajdować się w jedym z trzech stanów:
- spełniona (resolved) - gdy powiązane z nią zadania zwraca żądaną wartość,
- odrzucona (rejected) - gdy zadanie nie zwraca wartości, np. z powodu wyjątku, lub zwrócona wartość jest nieprawidłowa,
- oczekująca (pending) - to stan od rozpączęcia żądania do otrzymania wyniku.

W naszym przypadku ustawiłem wartość true dla stałej imCool co spełnia/rozwiązuje naszą obietnice i zwraca obiekt Promise do funkcji wywołującej.

Zatem przebieg całego skryptu wygląda następująco. Metoda init() wywołuje myAsync() i następnie (then) wywołana zostaje funckja która zgłasza alert z otrzymanym komunikatem. W przypadku gdy zmienimy wartość stałej dla imCool na false, obietnica zostanie odrzucona i wywołanie zostanie pominięte. Bład będziemy mogli przechwycić używając metody catch().

Opierając się na powyższym przykładzie może być trudno dostrzec korzyści płynące z użycia obietnic zamiast standardowych wywołań zwrotnych. Zazwyczaj jednak obietnic będziemy używać w kontekście tworzenia łańcuchów wywołań gdzie jedna obietnica będzie konsumować kolejną. Przyjrzyjmy się zatem bardziej rozbudowanemu przykładowi. (https://jsfiddle.net/0xrffx6a/)


// W poniższym przykładzie upieczemy kawałek ciasta.
// Aby dokonać tego będziemy potrzebować trzech kroków.

let doShopping = () => {return new Promise((resolve, reject) => resolve ('Got ingredients'))}
let mixIngredients = () => {return new Promise((resolve, reject) => resolve ('Made dough'))}
let bakeCake = () => {return new Promise((resolve, reject) => resolve ('Baked cake'))}

doShopping()
.then((response) => { alert(response); return mixIngredients() })
.then((response) => { alert(response); return bakeCake() })
.then((response) => { alert(response); alert('Bon appetit') });


Obietnice z czasem zdążyły tez ewoluować: obietnice async, generatory




